from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

import tensorflow as tf
from google.protobuf import text_format
from collections import Counter
import sys
import re

try:
    model_file_name = sys.argv[1]
except IndexError:
    print('Usage: python rnn_detector.py <MODEL_FILE.pbtxt>')

with open(model_file_name, 'r') as model_file:
    model_protobuf = text_format.Parse(model_file.read(),
                                       tf.GraphDef())

tf.import_graph_def(model_protobuf)
tensors = tf.get_default_graph().as_graph_def().node
MIN_NODES_PER_LAYER = 5  # this limit is for ignoring activation layers

# This regex designed to extract namespace,
# but it also extracts those that looks like "lstm_1_1"
# They're the dublicate layers generated by Fabrik for original one that supposed to be alone
# They could be ignored in preprocessing
namespace_re = re.compile(r'[^/]+/([^/]+)/?')
namespaces_count = Counter(namespace_re.search(n.name).group(1) for n in tensors)
namespaces = set(ns for ns, count in namespaces_count.items() if count >= MIN_NODES_PER_LAYER)

# simple stands for SimpleRNN
# but non_simple is GRU and LSTM altogether
# @TODO: differ GRU and LSTM
rec_namespaces = {'simple': [], 'non_simple': []}
for namespace in namespaces:
    suspect_ns_re = re.compile(namespace)
    tanhs = set(n.name for n in tensors if suspect_ns_re.search(n.name) and n.op == 'Tanh')
    if len(tanhs) == 0:
        continue
    muls = [n for n in tensors if suspect_ns_re.search(n.name) and n.op == 'Mul']
    is_identified = False
    for mul in muls:
        inputs = set(mul.input)
        if len(inputs & tanhs) != 0:
            rec_namespaces['non_simple'].append(namespace)
            is_identified = True
            break

    if not is_identified:
        rec_namespaces['simple'].append(namespace)


print('Detected recurrence:', rec_namespaces)
